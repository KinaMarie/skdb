title: architecture of skdb

main concepts:
- packages:
- dependencies:
    types:
        build:
            description:
                if Y must be used to make the part X
                then X has a build dependency on Y
                #note not all dependencies are parts
            examples:
                - a screw has a build dependency on a lathe
        assembly: comes after the build process; integrates component parts into an assembly part
        disassembly: undoes the steps in assembly process; decomposes assembly part into components           
        use: &use
            description:
                if part X is unusuable when without Y
                then X has a use dependency on Y
            examples:
                - a screw requires a nut in order to fasten something else
        run: *use
        software:
            description:
                if the skdb representation of X is unusuable without the skdb representation of Y
                then X has a software dependency on Y
            examples:
                - library header files required for compiling support into another program
                - precompiled object or shared library for link time (i.e., package X requires a shared library from Y if you compile package X)
                - precompiled object or shared library for software run time (i.e., package X loads up the lib.so file (not compiled in))
    dependency sets:
        each package has at least one dependency set that must be satisfied (in special cases that one set can be null)
        without satisfaction of a dependency set, the package is probably useless (a broken install)
        a package with multiple dependency sets allows there to be unique buildtime, runtime and software dependencies for different situations
        for instance, certain buildtime dependencies might demand certain runtime dependencies
- instructions:
    description:
        sequences of steps for humans and machines for any of the different scenarios (build, run etc.)
        usually generated by running instruction generation code from each of the dependencies
    wishlist:
        - zoomable text detail: see doug engelbart or code folding
        - 3D animation: see 'parameterized action representation' papers for neat diagrams #link?
        - 2D: see lego instructions
        - sentence planner: &spud
            - generate different sentences that say the same thing given the
              same input #for disambiguation?
            - English grammar
            - other natural languages
            - tree-adjoining grammars: xtag
    concepts:
        - AtomicAction: #camel case, really?
            - cannot be broken into sub-steps
            - EMC calls these "canonical commands"
        - CompoundAction: 
            - a (nested) set of actions
        - Action:
            - may be atomic or compound
            - precondition for an action to begin (applicability conditions)
            - postcondition for an action to end (culmination conditions)
            - has an agent or actor (formal cause)
            - object (that which is acted upon)
            - quantitative parameters #qualitative adjectives are poorly specified parameters
            - no specific sequence of actions unless necessary; step-by-step
              instructions are just a particular (optimal) serialization of action dependency tree
        - virtual human actors to verify and demonstrate instructions
        - virtual non-human agents to verify and simulate actions (robots, machinery)
    questions: #and answers, if you're lucky
        - where are steps (in instructions) written down in skdb?
        - how do you translate from an action to machine code:
            - CAM has a "post processor" which tailors the generic instructions for the
              individual machine tool/language
        - or natural language: *spud
        - how do instructions from other packages contribute to instructions for dependent packages?
        - a grammar for the language of human instructions? #what??
        - external references: see f16 maintenance manuals (internal fuel tank vent)

commands:
- skdb soft get #download skdb representations and software dependencies
- skdb hard get #figure out which dependency set to grab and the package to do buildtime and runtime, etc.
#how is this different from "skdb soft get"? why not just one command "skdb get" with depth parameter?

- skdb build lego #spit out instructions for buildtime of a certain package (and execute them)

- skdb run lathe #spit out instructions for runtime of a certain package
#huh? is this some kind of integrated help facility? just in time training? what?

#- skdb maintain drillpress #spit out instructions for maintenance time of a certain package
# maintenance really is part of use

- skdb uninstall #spit out instructions for disassembly, or commands to machines for disassembly, plus uninstall the skdb packages too
#hmmm.

